CALLIEIDEAS

Callie needs to adventure. Go out and find content. In this case, text content. Identify and read text content. Text content is within <p> tags, right? Find these things all over the web, through links from one to another. Then, store where you found them so you can look them up again.

findContent()

findContentRelatedTo(x)

Where x is a search reference, whether it is a picture, song, text, or whatever. 

Object: Person.

A person is a data object. Generally, we interact with people in a variety of ways. We read their content, we send them emails, that sort of thing.

March 1 - 572003529436622849

Feb 1 - 561875136597733377


We want to get ONE PAGE of tweets, interpret it, redo my list, then get the NEXT page of tweets. Gradually, these pages will become more cramped and cramped because the network will be getting larger and larger.

Get a page of tweets. Save the last id, progress

The way that this works, I will be working BACKWARDS from March 1 to Feb 1, since that's the way twitter works. That is wicked awkward.

Go For a month. Run the SinceID at starting at the beginning of the month and max id as starting at the end of the month.

Run the program continually for one week and see how it ends up.

Instead of using a static max list of people, we should add to the size of the list on the cadence. This data should probably be stored in NetworkXML

CreatingList Code.

Need to make this more efficient. Need to run the @___ against a list of things I already have so I don't have to do the wicked expensive operation of pinging the Twitter API for EVERY SINGLE NAME.

If that name is already in my system, there is no sense Wrecking myself by overloading on Pings. If it's in my list, don't run the ask for the ID from the server, just pull the ID from the list I already have. 


---------------
04/28/2015

CALLIEMachine Specification

A CallieMachine is a class.

It must have the following things.

It must be able to take in data, and give an output that is different from

Split a data up into its smallest possible parts. Then, rebuild the data structure based on how those parts are connected. Each part must be able to be referenced by a unique ID

CallieMachine {
	
	
}